<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Headhunter: The Infinite Pipeline</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/tsparticles@3.7.1/tsparticles.bundle.min.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #262626;
            touch-action: none; /* Prevent pull-to-refresh on mobile */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        canvas {
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }
        .pointer-events-auto {
            pointer-events: auto;
        }
        #ts-lightning-layer {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 3;
        }
        #ts-lightning-layer canvas {
            background: transparent !important;
            width: 100% !important;
            height: 100% !important;
            pointer-events: none !important;
        }
        /* CRT Scanline effect overlay */
        .scanlines {
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.1) 50%,
                rgba(0,0,0,0.1)
            );
            background-size: 100% 4px;
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            z-index: 10;
            pointer-events: none;
        }
        .card-hover:hover {
            transform: translateY(-4px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3);
        }
        .flash-red {
            animation: flashRed 0.2s ease-in-out;
        }
        @keyframes flashRed {
            0%, 100% { background-color: rgba(255, 0, 0, 0); }
            50% { background-color: rgba(255, 0, 0, 0.3); }
        }
        .flash-green {
            animation: flashGreen 0.2s ease-in-out;
        }
        @keyframes flashGreen {
            0%, 100% { background-color: rgba(0, 255, 0, 0); }
            50% { background-color: rgba(0, 255, 0, 0.2); }
        }
    </style>
</head>
<body class="text-white">

    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>
    <div id="damage-overlay" class="absolute inset-0 pointer-events-none"></div>
    <div class="scanlines"></div>
    <div id="ts-lightning-layer" class="absolute inset-0 pointer-events-none"></div>
    <div id="pause-overlay" class="hidden absolute inset-0 bg-black/80 flex flex-col items-center justify-center text-center text-white z-50 pointer-events-auto p-8">
        <div class="text-4xl font-bold mb-2 text-yellow-400">PAUSED</div>
        <div class="text-sm text-gray-400 mb-8">Press ESC to resume</div>
        <div id="pause-stats" class="grid grid-cols-1 md:grid-cols-2 gap-4 w-full max-w-2xl">
            <!-- Stats injected via JS -->
        </div>
    </div>

    <!-- UI Layer -->
    <div id="ui-layer" class="flex flex-col justify-between p-2 md:p-4">
        
        <!-- HUD -->
        <div id="hud" class="hidden flex justify-between items-start w-full pointer-events-none">
            <div class="flex flex-col gap-1 md:gap-2 max-w-full md:max-w-md w-full md:w-auto">
                <!-- Sanity Bar -->
                <div class="w-32 md:w-48 h-4 md:h-6 bg-gray-800 border-2 border-gray-600 rounded relative shadow-lg">
                    <div id="hp-bar" class="h-full bg-red-500 transition-all duration-200" style="width: 100%;"></div>
                    <span class="absolute inset-0 flex items-center justify-center text-[8px] md:text-xs font-bold text-white drop-shadow-md">SANITY</span>
                </div>
                <!-- XP Bar -->
                <div class="w-32 md:w-48 h-2 md:h-4 bg-gray-800 border border-gray-600 rounded relative mt-0 md:mt-1 shadow-lg">
                    <div id="xp-bar" class="h-full bg-blue-400 transition-all duration-200" style="width: 0%;"></div>
                </div>
                
                <!-- Info Panel - Squished on mobile -->
                <div class="bg-black/60 p-1 md:p-2 rounded border border-gray-700 backdrop-blur-sm mt-1 md:mt-2 text-[9px] md:text-xs font-mono w-fit md:w-full">
                    <div class="text-green-400 mb-0 md:mb-1 font-bold flex justify-between items-center">
                        <span>Lvl: <span id="level-display">1</span></span>
                    </div>
                    
                    <!-- Weapons Grid -->
                    <div class="mb-1 md:mb-2 flex items-center gap-2">
                        <div class="text-gray-400 uppercase tracking-wider text-[8px] md:text-[10px] hidden md:block">Toolkit</div>
                        <div id="weapon-grid" class="flex flex-wrap gap-1">
                            <!-- Injected JS -->
                        </div>
                    </div>

                    <!-- Stats Grid - Expanded for more stats -->
                    <div>
                        <div class="text-gray-400 uppercase tracking-wider text-[8px] md:text-[10px] mb-0 md:mb-1 hidden md:block">Metrics</div>
                        <!-- 6 Columns to fit everything -->
                        <div class="grid grid-cols-6 md:grid-cols-3 gap-x-1 md:gap-x-4 gap-y-0 md:gap-y-1 text-gray-300 leading-tight">
                            <div>SPD: <span id="stat-speed" class="text-white"></span></div>
                            <div>DMG: <span id="stat-dmg" class="text-white"></span></div>
                            <div>AREA: <span id="stat-area" class="text-white"></span></div>
                            <div>CDR: <span id="stat-cdr" class="text-white"></span></div>
                            <div>RNG: <span id="stat-range" class="text-white"></span></div>
                            <div>DIFF: <span id="stat-diff" class="text-white"></span></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="text-right font-mono">
                <div class="text-xl md:text-2xl font-bold text-yellow-400 drop-shadow-md" id="timer">00:00</div>
                <div class="text-xs md:text-sm text-gray-400 drop-shadow-md">Kills: <span id="kill-count">0</span></div>
            </div>
        </div>

        <!-- Boss HUD -->
        <div id="boss-hud" class="hidden absolute top-8 md:top-4 left-1/2 transform -translate-x-1/2 w-3/4 md:w-1/2 pointer-events-none z-20">
            <div id="boss-name" class="text-center text-purple-400 font-bold text-sm md:text-xl mb-1 drop-shadow-[0_2px_2px_rgba(0,0,0,0.8)] tracking-widest uppercase">BOSS NAME</div>
            <div class="w-full h-4 md:h-8 bg-gray-900 border-2 md:border-4 border-purple-900 rounded relative shadow-2xl overflow-hidden">
                <div id="boss-hp-bar" class="h-full bg-gradient-to-r from-purple-700 to-purple-500 transition-all duration-200" style="width: 100%;"></div>
            </div>
        </div>

        <!-- Start Screen -->
        <div id="start-screen" class="absolute inset-0 flex items-center justify-center bg-black/80 backdrop-blur-sm pointer-events-auto z-50">
            <div class="text-center max-w-md p-8 border-2 border-blue-500 bg-gray-900 rounded-lg shadow-2xl">
                <h1 class="text-5xl font-bold mb-2 text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-500">HEADHUNTER</h1>
                <h2 class="text-xl text-gray-300 mb-6">The Infinite Pipeline</h2>
                <p class="mb-6 text-gray-400">Survive the massive talent pool. Climb the corporate ladder.</p>
                
                <div class="flex flex-col gap-2 mb-6 text-sm text-left bg-gray-800 p-4 rounded">
                    <p>üéÆ <strong>WASD / Arrows</strong> or <strong>Touch Drag</strong> to Move</p>
                    <p>‚öîÔ∏è Attacks are <strong>Automatic</strong></p>
                    <p>üíé Collect <strong>Resumes</strong> to Level Up</p>
                    <p>üëπ Defeat the <strong>Angel Investor</strong> to Win</p>
                </div>

                <button onclick="startGame()" class="px-8 py-3 bg-blue-600 hover:bg-blue-500 text-white font-bold rounded text-lg transition transform active:scale-95 shadow-[0_0_15px_rgba(37,99,235,0.5)]">
                    OPEN REQUISITION
                </button>
            </div>
        </div>

        <!-- Level Up Modal -->
        <div id="upgrade-screen" class="hidden absolute inset-0 flex items-center justify-center bg-black/90 z-40 pointer-events-auto">
            <div class="w-full max-w-2xl p-6 bg-gray-900/80 rounded-xl border border-gray-700 backdrop-blur-md shadow-2xl flex flex-col items-center">
                <h2 id="upgrade-title" class="text-3xl font-bold text-center mb-2 text-yellow-400">PROMOTION AVAILABLE!</h2>
                <p class="text-center text-gray-400 mb-8">Choose a new skill for your toolkit <span class="text-xs opacity-60 block mt-1">(Use Arrow Keys / WASD to Select, Space/Enter to Confirm)</span></p>
                
                <div id="upgrade-container" class="grid grid-cols-1 md:grid-cols-3 gap-4 w-full">
                    <!-- Cards injected via JS -->
                </div>

                <!-- Reroll Button -->
                <button id="reroll-btn" onclick="rerollUpgrades()" class="mt-6 px-6 py-2 bg-gray-700 hover:bg-gray-600 text-white font-bold rounded border border-gray-500 transition flex items-center gap-2 group">
                    <span class="group-hover:text-yellow-200">üé≤ Reroll Options</span>
                    <span id="reroll-count" class="bg-black px-2 py-0.5 rounded text-xs text-yellow-400">3 Left</span>
                </button>
            </div>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen" class="hidden absolute inset-0 flex items-center justify-center bg-red-900/90 z-50 pointer-events-auto">
            <div class="text-center p-8 bg-black border-4 border-red-600 rounded-lg shadow-2xl max-w-lg w-full">
                <h2 class="text-6xl font-bold text-red-500 mb-2">FIRED</h2>
                <p class="text-xl text-white mb-6">Your performance review is in.</p>
                
                <!-- Static Termination Reason Area -->
                <div id="termination-letter" class="bg-white text-black p-4 rounded text-left font-mono text-sm mb-6 flex flex-col">
                    <div class="border-b border-gray-300 pb-2 mb-2 font-bold uppercase tracking-widest text-xs text-gray-500">HR Dept. Termination Notice</div>
                    <div id="static-text-content" class="italic text-gray-800">
                        <!-- Content injected via JS -->
                    </div>
                </div>

                <div class="text-2xl font-mono mb-8 space-y-2">
                    <div>Time Survived: <span id="final-time" class="text-yellow-400 font-bold">00:00</span></div>
                    <div>Candidates Rejected: <span id="final-kills" class="text-red-400 font-bold">0</span></div>
                </div>
                <button onclick="location.reload()" class="px-8 py-3 bg-white text-red-900 font-bold rounded text-lg hover:bg-gray-200 transition">
                    APPLY AGAIN
                </button>
            </div>
        </div>

        <!-- Win Screen -->
        <div id="win-screen" class="hidden absolute inset-0 flex items-center justify-center bg-green-900/90 z-50 pointer-events-auto">
            <div class="text-center p-8 bg-black border-4 border-green-500 rounded-lg shadow-2xl max-w-lg w-full">
                <h2 class="text-5xl font-bold text-green-400 mb-2">OFFER ACCEPTED</h2>
                <p class="text-xl text-white mb-6">You have acquired 100% of the market.</p>
                <div class="text-6xl mb-6">ü§ù</div>
                <div class="text-2xl font-mono mb-8 space-y-2">
                    <div>Time: <span id="win-time" class="text-yellow-400 font-bold">00:00</span></div>
                    <div>Rejections: <span id="win-kills" class="text-white font-bold">0</span></div>
                </div>
                <button onclick="location.reload()" class="px-8 py-3 bg-white text-green-900 font-bold rounded text-lg hover:bg-gray-200 transition">
                    START NEW QUARTER
                </button>
            </div>
        </div>
        
        <!-- Mobile Joystick Hint -->
        <div id="mobile-hint" class="absolute bottom-10 left-0 w-full text-center text-gray-500 opacity-50 text-sm pointer-events-none hidden md:hidden">
            Drag anywhere to move
        </div>
    </div>

    <script>
        /**
         * GAME CONFIGURATION & STATE
         */
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // World Dimensions
        const WORLD_WIDTH = 4000;
        const WORLD_HEIGHT = 4000;
        
        // Global ID Counter for safe collision tracking
        let GLOBAL_ID = 0;

        // Game State
        let gameState = 'START'; // START, PLAYING, PAUSED, GAMEOVER, WIN
        let lastTime = 0;
        let timer = 0;
        let animationId;
        let score = 0;
        let frameCount = 0; // Still useful for some modulos, but we prefer time-based
        let bossSpawned = false; 

        // Boss System
        let currentBossTier = 0;
        const BOSS_TIERS = [
            { name: "The Manager", emoji: "üò†", color: "#f87171" }, // Red
            { name: "The Director", emoji: "üßê", color: "#fbbf24" }, // Amber
            { name: "The VP", emoji: "üíº", color: "#34d399" }, // Emerald
            { name: "The CEO", emoji: "üëπ", color: "#9333ea" }, // Purple
            { name: "The Board Member", emoji: "üèõÔ∏è", color: "#2563eb" }, // Blue
            { name: "The Angel Investor", emoji: "üí∏", color: "#facc15" } // Gold (Final)
        ];

        // Camera
        let camera = { x: 0, y: 0, shake: 0 };
        
        // Inputs
        const keys = { w: false, a: false, s: false, d: false, ArrowUp: false, ArrowLeft: false, ArrowDown: false, ArrowRight: false };
        const touchInput = { active: false, startX: 0, startY: 0, currX: 0, currY: 0, dx: 0, dy: 0 };

        // Upgrade System State
        let upgradeOptions = [];
        let selectedUpgradeIndex = 0;
        let rerollsRemaining = 3;
        let isRerollFocused = false;

        // Game Objects
        let player;
        let enemies = [];
        let projectiles = [];
        let gems = []; 
        let damageNumbers = []; // Now stores {val, x, y, creationTime, duration, color}
        let particles = [];
        let lightnings = []; 
        let activeMiniLightnings = 0;
        let lastMiniEmitterTime = 0;
        let tsLightningContainer = null;
        let manualPause = false;
        let lingeringSparks = []; 
        let pulseWaves = [];

        const MAX_ACTIVE_MINI_LIGHTNINGS = 16;
       
        // Termination Reasons
        const TERMINATION_REASONS = [
            "We felt you weren't aligned with our core value of 'Synergistic Hustle'.",
            "You failed to circle back on the low-hanging fruit.",
            "We are pivoting to a more AI-driven recruitment strategy (cheaper).",
            "Your bandwidth was insufficient for the Q3 deliverables.",
            "We found a candidate who can do your job for exposure.",
            "You didn't 'Reply All' to the birthday email chain.",
            "Culturally, you're just not a 'Rockstar Ninja Guru' fit.",
            "We are rightsizing the human capital department effective immediately.",
            "You spent too much time reading resumes and not enough time 'networking'.",
            "The hiring manager ghosted us, so we are ghosting you."
        ];

        // Upgrade Pool - CLEANED DESCRIPTIONS + ADDED lvl2Text PROPERTY
        const UPGRADES = [
            { id: 'email', name: 'Cold Email', type: 'WEAPON', desc: 'Fires rapid rejection emails at nearest candidate.', lvl2Text: 'Lvl 2 Perk: Chilling Slow', lvl5Text: 'Lvl 5 Perk: Cold Splash AoE', icon: 'üìß' },
            { id: 'aura', name: 'Networking Aura', type: 'WEAPON', desc: 'Damages anyone getting too close to your network.', lvl2Text: 'Lvl 2 Perk: Slows Enemies', icon: 'üåê' },
            { id: 'offer', name: 'The Offer', type: 'WEAPON', desc: 'Slow moving, high damage projectile that pierces.', lvl2Text: 'Lvl 2 Perk: Stuns Enemies', icon: 'üíº' },
            { id: 'referral', name: 'Referral Chain', type: 'WEAPON', desc: 'Long-range arcs that bounce between candidates.', lvl2Text: 'Lvl 2 Perk: Double Shotgun Count', icon: '‚ö°' }, 
            { id: 'coffee', name: 'Caffeine IV', type: 'PASSIVE', stat: 'speed', val: 0.05, desc: 'Move faster.', icon: '‚òï' },
            { id: 'linkedin', name: 'Premium Sub', type: 'PASSIVE', stat: 'pickupRange', val: 50, desc: 'Gather resumes from further away.', icon: 'üîó' },
            { id: 'budget', name: 'Hiring Budget', type: 'PASSIVE', stat: 'damageMult', val: 0.1, desc: 'Increase all damage by 10%.', icon: 'üí∞' },
            { id: 'ats', name: 'ATS Filter', type: 'PASSIVE', stat: 'attackSpeed', val: 0.1, desc: 'Attack faster.', icon: 'ü§ñ' },
            { id: 'bigdata', name: 'Big Data', type: 'PASSIVE', stat: 'areaMult', val: 0.2, desc: 'Increase size of projectiles and effects by 20%.', icon: 'üíæ' },
            { id: 'growth', name: 'Hypergrowth', type: 'PASSIVE', stat: 'difficultyMult', val: 0.05, desc: 'Increase enemy spawn rate by 5% (More XP!).', icon: 'üìà' }
        ];

        /**
         * AUDIO SYSTEM
         */
        let lightningPlayers = null;
        let pitchShift = null;

        function initAudio() {
            if (lightningPlayers) return;

            // Create a PitchShift effect: -24 semitones (2 octaves down) 
            // We play at 2x speed (+1 octave), so net result is -1 octave (Deep) and Fast.
            pitchShift = new Tone.PitchShift(-60).toDestination();

            lightningPlayers = new Tone.Players({
                "lightning1": "sounds/lightning1.wav",
                "lightning2": "sounds/lightning2.wav",
                "lightning3": "sounds/lightning3.wav",
                "lightning4": "sounds/lightning4.wav"
            }).connect(pitchShift);
        }

        function playLightningSound() {
            if (!lightningPlayers || !lightningPlayers.loaded) return;
            
            const rand = Math.floor(Math.random() * 4) + 1;
            if (lightningPlayers.has(`lightning${rand}`)) {
                const player = lightningPlayers.player(`lightning${rand}`);
                player.playbackRate = 1;
                player.start();
            }
        }

        /**
         * CORE CLASSES
         */

        class Player {
            constructor() {
                this.x = WORLD_WIDTH / 2;
                this.y = WORLD_HEIGHT / 2;
                this.radius = 15;
                
                // Physics Props - MORE INERTIA
                this.vx = 0;
                this.vy = 0;
                this.acceleration = 0.12; 
                this.friction = 0.96; 
                this.maxSpeed = 2.2; 
                
                // Stats
                this.speed = 1.0; // Multiplier
                this.maxHp = 100;
                this.hp = 100;
                this.level = 1;
                this.xp = 0;
                this.xpToNext = 10;
                this.invincibilityTimer = 0; // I-Frames
                
                // Stats modifiers
                this.pickupRange = 80;
                this.damageMult = 1;
                this.attackSpeed = 1; // 1 = 100%
                this.areaMult = 1; 
                this.difficultyMult = 1; 

                // Inventory
                this.weapons = {
                    email: { level: 0, cooldown: 0, maxCooldown: 120, damage: 15 }, 
                    aura: { level: 0, cooldown: 0, maxCooldown: 20, damage: 2, range: 100 }, 
                    offer: { level: 0, cooldown: 0, maxCooldown: 240, damage: 50, range: 480 },
                    referral: { level: 0, cooldown: 0, maxCooldown: 500, damageMin: 1, damageMax: 7, bounce: 3, range: 380 }
                };
            }

            update(timeScale) {
                // 1. Handle Input -> Acceleration
                let ax = 0;
                let ay = 0;

                if (keys.w || keys.ArrowUp) ay -= 1;
                if (keys.s || keys.ArrowDown) ay += 1;
                if (keys.a || keys.ArrowLeft) ax -= 1;
                if (keys.d || keys.ArrowRight) ax += 1;

                if (touchInput.active) {
                    ax = touchInput.dx;
                    ay = touchInput.dy;
                }

                // Normalize input vector
                if (ax !== 0 || ay !== 0) {
                    const len = Math.hypot(ax, ay);
                    if (len > 1) { 
                        ax /= len;
                        ay /= len;
                    }
                }

                // 2. Apply Acceleration (Scaled by timeScale)
                const currentAccel = this.acceleration * this.speed;
                this.vx += ax * currentAccel * timeScale;
                this.vy += ay * currentAccel * timeScale;

                // 3. Apply Friction (Exponential decay approximation)
                // v = v * f^timeScale
                this.vx *= Math.pow(this.friction, timeScale);
                this.vy *= Math.pow(this.friction, timeScale);

                // 4. Cap Velocity
                const currentMaxSpeed = this.maxSpeed * this.speed;
                const velMag = Math.hypot(this.vx, this.vy);
                if (velMag > currentMaxSpeed) {
                    this.vx = (this.vx / velMag) * currentMaxSpeed;
                    this.vy = (this.vy / velMag) * currentMaxSpeed;
                }

                // 5. Update Position (Velocity is per frame, so scale it)
                this.x += this.vx * timeScale;
                this.y += this.vy * timeScale;

                // 6. Stop if very slow
                if (Math.abs(this.vx) < 0.01) this.vx = 0;
                if (Math.abs(this.vy) < 0.01) this.vy = 0;

                // 7. Boundaries
                this.x = Math.max(this.radius, Math.min(WORLD_WIDTH - this.radius, this.x));
                this.y = Math.max(this.radius, Math.min(WORLD_HEIGHT - this.radius, this.y));

                // 8. Invincibility (Frame based, scale it)
                if (this.invincibilityTimer > 0) {
                    this.invincibilityTimer -= timeScale;
                }

                // Weapon Logic
                this.handleWeapons(timeScale);

                // XP Collection
                this.checkPickups(timeScale);
            }

            checkPickups(timeScale) {
                for (let i = gems.length - 1; i >= 0; i--) {
                    // CRITICAL FIX: Stop processing pickups if game paused (e.g. Level Up)
                    if (gameState !== 'PLAYING') return;

                    const g = gems[i];
                    const dist = Math.hypot(g.x - this.x, g.y - this.y);
                    
                    // Magnetic pull - Normal or Magnetized
                    if (dist < this.pickupRange || g.magnetized) {
                        // Speed up closer for normal, constant VERY fast for magnet
                        const speed = g.magnetized ? 30 : 0.15 * (dist + 10); 
                        
                        if (g.magnetized) {
                            const angle = Math.atan2(this.y - g.y, this.x - g.x);
                            g.x += Math.cos(angle) * speed * timeScale;
                            g.y += Math.sin(angle) * speed * timeScale;
                        } else {
                            // Classic easing
                            g.x += (this.x - g.x) * 0.15 * timeScale;
                            g.y += (this.y - g.y) * 0.15 * timeScale;
                        }
                    }
                    
                    // Collect
                    if (dist < this.radius + g.radius) {
                        if (g.type === 'xp') {
                            // Base XP increased (Was * 2, now * 2.5)
                            this.xp += g.val * 2.5;
                        } else if (g.type === 'pizza') {
                             this.hp = Math.min(this.maxHp, this.hp + 10);
                             addDamageNumber("HP +10", this.x, this.y - 30, '#4ade80');
                             document.getElementById('damage-overlay').classList.add('flash-green');
                             setTimeout(() => document.getElementById('damage-overlay').classList.remove('flash-green'), 200);
                        } else if (g.type === 'magnet') {
                            // Magnetize ALL existing gems
                            gems.forEach(gem => gem.magnetized = true);
                            addDamageNumber("MAGNET!", this.x, this.y - 30, '#ffffff');
                        }

                        gems.splice(i, 1);
                        
                        // Multi-level up loop
                        if (this.xp >= this.xpToNext) {
                            this.levelUp();
                        }
                        updateHUD();
                    }
                }
            }

            levelUp() {
                this.level++;
                this.xp -= this.xpToNext; 
                this.xpToNext = Math.floor(this.xpToNext * 1.5);
                gameState = 'PAUSED';
                showUpgrades();
            }

            upgrade(id) {
                const up = UPGRADES.find(u => u.id === id);
                if (up.type === 'WEAPON') {
                    this.weapons[id].level++;
                } else {
                    this[up.stat] += up.val;
                }
                this.hp = Math.min(this.maxHp, this.hp + 15);
                updateHUD();
            }

            draw() {
                if (this.weapons.aura.level > 0) {
                    ctx.beginPath();
                    // Visual aura size scales with AreaMult
                    const visualRange = (this.weapons.aura.range + (this.weapons.aura.level * 15)) * this.areaMult;
                    ctx.arc(this.x, this.y, visualRange, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(0, 255, 255, ${0.2 + (Math.sin(Date.now() / 200) * 0.1)})`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                ctx.save();
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#3b82f6';
                ctx.font = "30px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                if (this.invincibilityTimer > 0 && Math.floor(Date.now() / 50) % 2 === 0) {
                    ctx.globalAlpha = 0.5;
                }
                ctx.fillText("üëî", this.x, this.y);
                ctx.restore();
            }

            handleWeapons(timeScale) {
                // Calculate Range Multiplier from Area (0.2x effectiveness)
                const rangeMult = 1 + (this.areaMult - 1) * 0.2;

                // 1. Cold Email
                const attackSpeedFactor = Math.max(0.1, this.attackSpeed);

                if (this.weapons.email.level > 0) {
                    this.weapons.email.cooldown -= timeScale;
                    if (this.weapons.email.cooldown <= 0) {
                        const target = getTarget(this.x, this.y, 400 * rangeMult, 'nearest');
                        if (target) {
                            const baseCd = Math.max(20, this.weapons.email.maxCooldown * (1 - (this.weapons.email.level * 0.1)));
                            this.weapons.email.cooldown = baseCd / attackSpeedFactor;
                            const dmg = (this.weapons.email.damage + (Math.pow(this.weapons.email.level, 1.3))) * this.damageMult;
                            const angle = Math.atan2(target.y - this.y, target.x - this.x);
                            projectiles.push(new Projectile(this.x, this.y, angle, 'email', dmg));
                        }
                    }
                }

                // 2. Aura (Area Damage + Slow at Lvl 2)
                if (this.weapons.aura.level > 0) {
                    this.weapons.aura.cooldown -= timeScale;
                    if (this.weapons.aura.cooldown <= 0) {
                        this.weapons.aura.cooldown = 50; 
                        const range = (this.weapons.aura.range + (this.weapons.aura.level * 15)) * this.areaMult;
                        const dmg = (this.weapons.aura.damage * this.weapons.aura.level) * this.damageMult;

                        enemies.forEach(enemy => {
                            const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                            if (dist < range) {
                                enemy.takeDamage(dmg, '#2dd4bf', true, 0.1); 
                                createExplosion(enemy.x, enemy.y, '#00ffff', 1); 
                                
                                if (this.weapons.aura.level >= 2) {
                                    enemy.slowTimer = 180; 
                                }
                            }
                        });
                    }
                }

                // 3. The Offer
                if (this.weapons.offer.level > 0) {
                    this.weapons.offer.cooldown -= timeScale;
                    if (this.weapons.offer.cooldown <= 0) {
                        const baseCd = Math.max(80, this.weapons.offer.maxCooldown * (1 - (this.weapons.offer.level * 0.15)));
                        this.weapons.offer.cooldown = baseCd / attackSpeedFactor;
                        const dmg = (this.weapons.offer.damage + (this.weapons.offer.level * 15)) * this.damageMult;
                        const offerRange = (this.weapons.offer.range || 600) * rangeMult;
                        const target = getTarget(this.x, this.y, offerRange, 'strongestNearest');
                        let angle = Math.random() * Math.PI * 2;
                        
                        if (target) {
                            angle = Math.atan2(target.y - this.y, target.x - this.x);
                        }
                        projectiles.push(new Projectile(this.x, this.y, angle, 'offer', dmg));
                    }
                }

                // 4. Referral Chain
                if (this.weapons.referral.level > 0) {
                    this.weapons.referral.cooldown -= timeScale;
                    if (this.weapons.referral.cooldown <= 0) {
                        const stats = this.weapons.referral;
                        const baseCd = Math.max(40, stats.maxCooldown * (1 - (stats.level * 0.1)));
                        stats.cooldown = baseCd / attackSpeedFactor;

                        // Shotgun 3 bolts (Doubles at Lvl 2)
                        let shotCount = 3;
                        if (stats.level >= 2) {
                            shotCount *= 2; 
                        }
                        
                        let initialHitList = []; 
                        let hasFired = false;

                        for(let s=0; s<shotCount; s++) {
                            // Always limit bounces to 3
                            let bounces = 3; 
                            
                            // Range-based damage calculation
                            const levelBonus = stats.level;
                            // Updated formula: (stats.damageMax + levelBonus) * this.damageMult * 1.1
                            // Min damage is half of max damage
                            const maxDmgBase = (stats.damageMax + levelBonus) * this.damageMult * 1.1;
                            let minDmgBase = maxDmgBase / 2;

                            if (stats.level >= 5) {
                                minDmgBase *= 1.5;
                                bounces += 1;
                            }
                            
                            let currentMin = minDmgBase;
                            let currentMax = maxDmgBase;
                            let currentSource = { x: this.x, y: this.y };
                            
                            // Visual Variant for Level 5+
                            const visualVariant = stats.level >= 5 ? 'level5' : 'default';
                            let currentWidth = stats.level >= 5 ? 6 : 3;
                            
                            // Use initialHitList to find unique starting targets, but don't pass it to the chain loop
                            // because we want each chain to be able to bounce freely (except to itself)
                            let target = getTarget(this.x, this.y, stats.range * rangeMult, 'weakest', initialHitList);
                            
                            if (target) {
                                if (!hasFired) {
                                    playLightningSound();
                                    hasFired = true;
                                }

                                initialHitList.push(target);
                                let chainHitList = [target]; // Prevent immediate back-bounce
                                let accumulatedDelay = s * 5; // Slight stagger for visual flair

                                // Process the first hit (the shotgun blast)
                                const firstTarget = target;
                                // Randomize damage for this instance
                                const firstDamage = Math.random() * (currentMax - currentMin) + currentMin;

                                addLightningVisual(createLightningVisual(currentSource.x, currentSource.y, target.x, target.y, '#facc15', 'main', 150, { 
                                    delay: accumulatedDelay,
                                    variant: visualVariant,
                                    width: currentWidth,
                                    onHit: () => {
                                        if (firstTarget.hp > 0) {
                                            firstTarget.takeDamage(firstDamage, '#facc15');
                                        }
                                    }
                                }));
                                
                                accumulatedDelay += 20;
                                currentSource = target;

                                const scaleDown = 0.5;
                                currentMin *= scaleDown;
                                currentMax *= scaleDown;
                                currentWidth = Math.max(1, currentWidth * 0.7); // Decay width

                                // minimum damage should be 1
                                if (currentMax < 1) currentMax = 1;
                                if (currentMin < 1) currentMin = 1;

                                // Continue the chain
                                while (bounces > 0) {
                                    target = getTarget(currentSource.x, currentSource.y, stats.range, 'random', chainHitList);
                                    if (!target) break;

                                    chainHitList.push(target);
                                    
                                    const currentTarget = target;
                                    const currentDamage = Math.random() * (currentMax - currentMin) + currentMin;

                                    addLightningVisual(createLightningVisual(currentSource.x, currentSource.y, target.x, target.y, '#facc15', 'main', 150, { 
                                        delay: accumulatedDelay,
                                        variant: visualVariant,
                                        width: currentWidth,
                                        onHit: () => {
                                            if (currentTarget.hp > 0) {
                                                currentTarget.takeDamage(currentDamage, '#facc15');
                                            }
                                        }
                                    }));
                                    
                                    accumulatedDelay += 20;
                                    currentSource = target;
                                    bounces--;
                                    currentMin *= scaleDown;
                                    currentMax *= scaleDown;
                                    currentWidth = Math.max(1, currentWidth * 0.7); // Decay width

                                    // minimum damage should be 1
                                    if (currentMax < 1) currentMax = 1;
                                    if (currentMin < 1) currentMin = 1;
                                }
                            }
                        }
                    }
                }
            }
        }

        class Enemy {
            constructor(type, bossTierOverride, spawnX, spawnY) {
                this.id = ++GLOBAL_ID; 
                
                if (spawnX !== undefined && spawnY !== undefined) {
                    this.x = spawnX;
                    this.y = spawnY;
                } else {
                    const angle = Math.random() * Math.PI * 2;
                    const minSpawnDist = Math.max(canvas.width, canvas.height) / 1.5;
                    const maxSpawnDist = minSpawnDist + 400;
                    const dist = minSpawnDist + Math.random() * (maxSpawnDist - minSpawnDist);

                    this.x = player.x + Math.cos(angle) * dist;
                    this.y = player.y + Math.sin(angle) * dist;
                }

                this.x = Math.max(20, Math.min(WORLD_WIDTH - 20, this.x));
                this.y = Math.max(20, Math.min(WORLD_HEIGHT - 20, this.y));

                this.type = type;
                this.knockback = {x:0, y:0};
                this.maxHp = 0;
                this.bossTierIndex = -1;
                
                this.stunTimer = 0;
                this.slowTimer = 0;
                this.splashCooldown = 0; 

                if (type === 'basic') {
                    this.hp = 20 + (timer/2.5); 
                    this.speed = 0.4 + (Math.random() * 0.2); 
                    this.damage = 5;
                    this.color = '#9ca3af';
                    this.emoji = "üìÑ"; 
                    this.radius = 12;
                    this.xpVal = 1;
                } else if (type === 'fast') {
                    this.hp = 10 + (timer/2.5);
                    this.speed = 1.35; 
                    this.damage = 3;
                    this.color = '#ef4444';
                    this.emoji = "üëª"; 
                    this.radius = 10;
                    this.xpVal = 10; 
                } else if (type === 'tank') {
                    this.hp = (80 + (timer/1.5)) * 4; 
                    this.speed = 0.25;
                    this.damage = 15;
                    this.color = '#f59e0b';
                    this.emoji = "ü§¨";
                    this.radius = 18;
                    this.xpVal = 20; 
                } else if (type === 'boss') {
                    const tierIndex = (bossTierOverride !== undefined) ? bossTierOverride : 0;
                    const tierData = BOSS_TIERS[tierIndex] || BOSS_TIERS[0];
                    const tierMultiplier = Math.pow(2, tierIndex); 
                    
                    // Base Boss HP 2000
                    this.hp = 2000 * tierMultiplier; 
                    this.damage = 50;
                    this.speed = 0.35; 
                    this.color = tierData.color; 
                    this.emoji = tierData.emoji; 
                    this.name = tierData.name;
                    this.radius = 60; 
                    this.xpVal = 400; 
                    this.bossTierIndex = tierIndex;
                }
                this.maxHp = this.hp;
            }

            update(timeScale) {
                // Stun Logic
                if (this.stunTimer > 0) {
                    this.stunTimer -= timeScale;
                } else {
                    const angle = Math.atan2(player.y - this.y, player.x - this.x);
                    
                    let currentSpeed = this.speed;
                    if (this.slowTimer > 0) {
                        currentSpeed *= 0.6; 
                        this.slowTimer -= timeScale;
                    }
                    
                    this.x += Math.cos(angle) * currentSpeed * timeScale;
                    this.y += Math.sin(angle) * currentSpeed * timeScale;
                }
                
                // Separation Logic
                for (let other of enemies) {
                    if (other === this) continue;
                    const dx = this.x - other.x;
                    const dy = this.y - other.y;
                    const distSq = dx*dx + dy*dy;
                    const minDist = this.radius + other.radius;
                    
                    if (distSq < minDist * minDist && distSq > 0) {
                        const dist = Math.sqrt(distSq);
                        const push = (minDist - dist) / dist * 0.5; 
                        this.x += dx * push * timeScale * 0.1; 
                        this.y += dy * push * timeScale * 0.1;
                    }
                }

                // Apply knockback decay
                this.x += this.knockback.x * timeScale;
                this.y += this.knockback.y * timeScale;
                this.knockback.x *= Math.pow(0.8, timeScale);
                this.knockback.y *= Math.pow(0.8, timeScale);

                // Collision with Player
                const dist = Math.hypot(player.x - this.x, player.y - this.y);
                if (dist < player.radius + this.radius) {
                    if (player.invincibilityTimer <= 0) {
                        player.hp -= this.damage;
                        addDamageNumber(Math.floor(this.damage), player.x, player.y - 20, '#ff0000');
                        player.invincibilityTimer = 30;
                        document.getElementById('damage-overlay').classList.add('flash-red');
                        setTimeout(() => document.getElementById('damage-overlay').classList.remove('flash-red'), 200);
                        this.knockback.x = -Math.cos(Math.atan2(player.y - this.y, player.x - this.x)) * 10;
                        this.knockback.y = -Math.sin(Math.atan2(player.y - this.y, player.x - this.x)) * 10;
                        camera.shake = 5;
                        if (player.hp <= 0) endGame();
                        updateHUD();
                    }
                }
            }

            takeDamage(amt, color = '#ffffff', isEffect = false, knockbackMult = 1.0) {
                // Prevent splash damage spam (Vaporization Fix)
                if (isEffect && color === '#fca5a5') { 
                     if (this.splashCooldown > 0) return false;
                     this.splashCooldown = 5; 
                }

                this.hp -= amt;
                addDamageNumber(Math.floor(amt), this.x, this.y, color, isEffect);
                
                const angle = Math.atan2(this.y - player.y, this.x - player.x);
                const resistance = this.type === 'boss' ? 0.1 : 2;
                this.knockback.x = Math.cos(angle) * resistance * knockbackMult;
                this.knockback.y = Math.sin(angle) * resistance * knockbackMult;

                if (this.hp <= 0) {
                    if (this.type === 'boss' && this.bossTierIndex === BOSS_TIERS.length - 1) {
                        winGame();
                        return true;
                    }

                    // ITEM DROPS: Pizza (0.5%) or Magnet (0.1%)
                    if (Math.random() < 0.005) {
                         gems.push({x: this.x, y: this.y, type: 'pizza', val: 0, radius: 10, color: 'white'});
                    } else if (Math.random() < 0.001) {
                         gems.push({x: this.x, y: this.y, type: 'magnet', val: 0, radius: 10, color: 'red'});
                    } else {
                        // XP GEMS
                        let gColor = '#60a5fa';
                        let gRadius = 4;
                        if (this.xpVal >= 400) { gColor = '#a855f7'; gRadius = 15; }
                        else if (this.xpVal >= 10) { gColor = '#4ade80'; gRadius = 8; }
                        else if (this.xpVal >= 5) { gColor = '#ef4444'; gRadius = 6; }

                        gems.push({x: this.x, y: this.y, type: 'xp', val: this.xpVal, radius: gRadius, color: gColor});
                    }
                    
                    score++;
                    
                    if (this.type === 'boss') {
                        camera.shake = 20;
                        bossSpawned = false; 
                    }
                    
                    return true; 
                }
                return false;
            }

            draw() {
                if (this.x < camera.x - 50 || this.x > camera.x + canvas.width + 50 ||
                    this.y < camera.y - 50 || this.y > camera.y + canvas.height + 50) {
                    return;
                }

                ctx.font = `${this.radius*2}px Arial`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                
                ctx.save();
                ctx.fillStyle = '#ffffff';

                if (this.stunTimer > 0) {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = 'gold';
                } else if (this.slowTimer > 0) {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = 'cyan';
                    ctx.save();
                    ctx.fillStyle = 'rgba(135, 206, 250, 0.5)'; 
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
                    ctx.fill();
                    ctx.restore();
                }

                if (this.type === 'fast' && this.x > player.x) {
                    ctx.scale(-1, 1);
                    ctx.fillText(this.emoji, -this.x, this.y);
                } else {
                    ctx.fillText(this.emoji, this.x, this.y);
                }
                
                if (this.stunTimer > 0) {
                    ctx.font = "12px Arial";
                    ctx.fillText("üîí", this.x, this.y - this.radius - 5);
                }

                ctx.restore();
            }
        }

        class Projectile {
            constructor(x, y, angle, type, damage) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.type = type;
                this.damage = damage;
                this.markedForDeletion = false;
                this.hitList = []; 

                if (type === 'email') {
                    this.speed = 4; 
                    // Scale size with AreaMult
                    this.radius = 8 * player.areaMult;
                    this.pierce = 1;
                    this.life = 120; 
                    this.emoji = 'üìß';
                } else if (type === 'offer') {
                    this.speed = 2; 
                    this.radius = 14 * player.areaMult;
                    this.pierce = 999;
                    this.life = 240; 
                    this.emoji = 'üíº';
                }
            }

            update(timeScale) {
                this.x += Math.cos(this.angle) * this.speed * timeScale;
                this.y += Math.sin(this.angle) * this.speed * timeScale;
                this.life -= timeScale;

                if (this.life <= 0 || 
                    this.x < 0 || this.x > WORLD_WIDTH || 
                    this.y < 0 || this.y > WORLD_HEIGHT) {
                    this.markedForDeletion = true;
                }
            }

            draw() {
                 if (this.x < camera.x - 50 || this.x > camera.x + canvas.width + 50 ||
                    this.y < camera.y - 50 || this.y > camera.y + canvas.height + 50) {
                    return;
                }
                ctx.font = `${this.radius*2}px Arial`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                ctx.fillText(this.emoji, 0, 0);
                ctx.restore();
            }
        }
        
        class PulseWave {
            constructor(x, y, maxRadius) {
                this.x = x;
                this.y = y;
                this.radius = 0;
                // Scale max radius with AreaMult
                this.maxRadius = maxRadius * player.areaMult;
                this.life = 1.0; 
                this.speed = 4; 
            }
            
            update(timeScale) {
                this.radius += this.speed * timeScale;
                this.life -= 0.025 * timeScale; 
            }
            
            draw() {
                 if (this.x < camera.x - 50 || this.x > camera.x + canvas.width + 50 ||
                    this.y < camera.y - 50 || this.y > camera.y + canvas.height + 50) {
                    return;
                }
                if (this.life <= 0) return;
                
                ctx.save();
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(252, 165, 165, ${this.life})`; 
                ctx.lineWidth = 3;
                ctx.stroke();
                ctx.fillStyle = `rgba(252, 165, 165, ${this.life * 0.2})`;
                ctx.fill();
                ctx.restore();
            }
        }

        class LingeringSpark {
            constructor(x, y, damage) {
                this.x = x;
                this.y = y;
                this.damage = damage;
                this.life = 120; 
                // Scale size with AreaMult
                this.radius = 20 * player.areaMult; 
                this.tickRate = 60; 
                this.tickTimer = 0;
                this.hitCount = 0;
                this.maxHits = 5; 
            }
            
            update(timeScale) {
                this.life -= timeScale;
                this.tickTimer += timeScale;

                if (this.life > 0 && Math.random() < 0.8 * timeScale) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * this.radius * 0.8;
                    const px = this.x + Math.cos(angle) * dist;
                    const py = this.y + Math.sin(angle) * dist;
                    const vx = (Math.random() - 0.5) * 3;
                    const vy = Math.random() * -4 - 1; 
                    const color = Math.random() > 0.3 ? '#fef08a' : '#ffffff';
                    particles.push(new Particle(px, py, color, {x: vx, y: vy}, 15, (Math.random() * 2 + 0.5) * player.areaMult));
                }
            }
            
            draw() {
                // Invisible emitter now.
            }
        }

        class Particle {
            constructor(x, y, color, velocity, life = 30, size = 3, options = {}) {
                this.x = x;
                this.y = y;
                this.color = color;
                if (velocity) {
                    this.vx = velocity.x;
                    this.vy = velocity.y;
                } else {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 2;
                    this.vx = Math.cos(angle) * speed;
                    this.vy = Math.sin(angle) * speed;
                }
                this.life = life;
                this.startLife = life;
                this.size = size;
                this.friction = options.friction !== undefined ? options.friction : 0.9;
                this.gravity = options.gravity || 0;
                this.fade = options.fade !== undefined ? options.fade : true;
                this.sizeDecay = options.sizeDecay || 0.98;
                this.shape = options.shape || 'circle';
                this.angle = options.angle || 0;
                this.rotationSpeed = options.rotationSpeed || 0;
            }
            update(timeScale) {
                this.vx *= Math.pow(this.friction, timeScale);
                this.vy *= Math.pow(this.friction, timeScale);
                this.vy += this.gravity * timeScale;
                this.x += this.vx * timeScale;
                this.y += this.vy * timeScale;
                this.size *= Math.pow(this.sizeDecay, timeScale);
                this.life -= timeScale;
                this.angle += this.rotationSpeed * timeScale;
            }
            draw() {
                 if (this.x < camera.x || this.x > camera.x + canvas.width ||
                    this.y < camera.y || this.y > camera.y + canvas.height) return;

                const opacity = this.fade ? Math.max(0, this.life / this.startLife) : 1;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                ctx.fillStyle = this.color;
                ctx.globalAlpha = opacity;
                
                if (this.shape === 'icicle') {
                    // Draw a long shard
                    ctx.beginPath();
                    ctx.moveTo(0, -this.size);
                    ctx.lineTo(this.size * 0.3, this.size);
                    ctx.lineTo(-this.size * 0.3, this.size);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    ctx.arc(0, 0, Math.max(0, this.size), 0, Math.PI*2);
                    ctx.fill();
                }
                ctx.restore();
            }
        }

        /**
         * UTILITIES
         */
        // New Targeting Utility (Replaces getNearestEnemy)
        function getTarget(x, y, range = 400, type = 'nearest', excludeList = []) {
            let best = null;
            let record;
            let recordDist = Infinity; // Track distance for tie-breaking

            if (type === 'weakest' || type === 'nearest') {
                record = Infinity;
            } else {
                record = -Infinity;
            }

            let candidates = []; // For random selection

            for (let e of enemies) {
                if (excludeList.includes(e)) continue;
                
                const dist = Math.hypot(e.x - x, e.y - y);
                if (dist > range) continue;

                if (type === 'random') {
                    candidates.push(e);
                    continue;
                }

                if (type === 'nearest') {
                    if (dist < record) {
                        record = dist;
                        best = e;
                    }
                } else if (type === 'strongest' || type === 'strongestNearest') {
                    const hpMetric = e.maxHp;
                    if (hpMetric > record || (hpMetric === record && dist < recordDist)) {
                        record = hpMetric;
                        recordDist = dist;
                        best = e;
                    }
                } else if (type === 'weakest') {
                    const hpMetric = e.hp;
                    if (hpMetric < record || (hpMetric === record && dist < recordDist)) {
                        record = hpMetric;
                        recordDist = dist;
                        best = e;
                    }
                }
            }

            if (type === 'random') {
                if (candidates.length > 0) {
                    return candidates[Math.floor(Math.random() * candidates.length)];
                }
                return null;
            }

            return best;
        }
        
        // Legacy support if called elsewhere, mapped to new function
        function getNearestEnemy(x, y) {
            return getTarget(x, y, 400, 'nearest');
        }

        // Updated to accept isEffect flag
        function addDamageNumber(val, x, y, color, isEffect = false) {
            let offsetX = 0;
            let offsetY = 0;
            
            if (isEffect) {
                offsetX = (Math.random() * 30) - 15;
                offsetY = -15;
            }

            damageNumbers.push({
                val, 
                x: x + offsetX, 
                y: y + offsetY, 
                creationTime: Date.now(), 
                duration: 600, 
                color,
                isEffect
            });
        }
        
        function createExplosion(x, y, color, count) {
            for(let i=0; i<count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 4 + 2;
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;
                // Particle size scaled by areaMult
                particles.push(new Particle(x, y, color, {x: vx, y: vy}, 40, (Math.random() * 2 + 1) * player.areaMult));
            }
        }
        
        function createSplash(x, y, damage, ignoredTarget = null) {
            pulseWaves.push(new PulseWave(x, y, 120));
            createExplosion(x, y, '#ffffff', 6);
            
            enemies.forEach(e => {
                if (e === ignoredTarget) return; 
                const dist = Math.hypot(e.x - x, e.y - y);
                if (dist < 120 * player.areaMult) { 
                    // Passes true for isEffect to trigger cooldown check
                    e.takeDamage(damage, '#fca5a5', true);
                }
            });
        }

        function applyColdSlow(enemy, duration = 150) {
            if (!enemy) return;
            enemy.slowTimer = Math.max(enemy.slowTimer, duration);
        }

        function createColdSplash(x, y, damage, options = {}) {
            const radius = (options.radius || 110); // Pass base radius, ArcWave handles areaMult
            const slowDuration = options.slowDuration || 150;
            const ignoredTarget = options.ignoredTarget || null;
            const angle = options.angle || 0;

            // Use ArcWave for U-shape shield effect - Handles Damage Now
            pulseWaves.push(new ArcWave(x, y, angle, radius, damage, slowDuration, ignoredTarget));
            
            // Directional particle burst (Backwards from impact) - SNOWY
            createParticleBurst({
                x,
                y,
                count: 24, // More snow
                color: '#ffffff',
                palette: ['#ffffff', '#e0f2fe', '#dbeafe'],
                speed: 3.0,
                life: 45,
                size: 2.5,
                gravity: 0.02, // Gentle fall
                friction: 0.94,
                fade: true,
                spread: Math.PI * 0.9, // Wide cone
                direction: angle + Math.PI // Opposite to projectile direction
            });

            // ICICLES (Bigger, sharper shards)
            createParticleBurst({
                x,
                y,
                count: 8, 
                color: '#bae6fd',
                palette: ['#bae6fd', '#7dd3fc', '#ffffff'],
                speed: 4.5, // Faster explosion
                life: 80, // ~1.3 seconds
                size: 12.0, // Much bigger
                gravity: 0.05, 
                friction: 0.92,
                fade: true,
                spread: Math.PI * 0.7, 
                direction: angle + Math.PI,
                shape: 'icicle',
                sizeDecay: 0.99 // Don't shrink too fast
            });
        }

        function addLightningVisual(visual) {
            if (!visual) return;
            if (visual.type === 'mini') {
                if (activeMiniLightnings >= MAX_ACTIVE_MINI_LIGHTNINGS) return;
                activeMiniLightnings++;
            }
            lightnings.push(visual);
        }

        function createParticleBurst({ x, y, count = 12, color = '#ffffff', palette = null, speed = 2, life = 25, size = 2, spread = Math.PI * 2, direction = 0, gravity = 0, fade = true, friction = 0.88, sizeDecay = 0.97, shape = 'circle' }) {
            for (let i = 0; i < count; i++) {
                const angle = direction + (Math.random() * spread) - (spread / 2);
                const magnitude = (0.3 + Math.random()) * speed;
                const vx = Math.cos(angle) * magnitude;
                const vy = Math.sin(angle) * magnitude;
                const particleLife = life + Math.random() * life * 0.3;
                const particleSize = size + Math.random() * size * 0.5;
                const chosenColor = Array.isArray(palette) && palette.length ? palette[Math.floor(Math.random() * palette.length)] : color;
                
                // Random rotation for icicles
                const rotationSpeed = shape === 'icicle' ? (Math.random() - 0.5) * 0.2 : 0;
                const initialAngle = shape === 'icicle' ? Math.random() * Math.PI * 2 : 0;

                particles.push(new Particle(x, y, chosenColor || color, { x: vx, y: vy }, particleLife, particleSize, { gravity, fade, friction, sizeDecay, shape, angle: initialAngle, rotationSpeed }));
            }
        }

        class ArcWave {
            constructor(x, y, angle, maxRadius, damage, slowDuration, ignoredTarget) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.radius = 10;
                this.maxRadius = maxRadius * player.areaMult;
                this.life = 1.0;
                this.speed = 5;
                
                // Damage Logic
                this.damage = damage;
                this.slowDuration = slowDuration;
                this.ignoredTarget = ignoredTarget;
                this.hitList = [];
            }
            update(timeScale) {
                this.radius += this.speed * timeScale;
                this.life -= 0.03 * timeScale;

                // Collision Check (Wave Front)
                if (this.life > 0) {
                    const waveThickness = 25; // Thickness of the damaging wave
                    const innerRadius = this.radius - waveThickness;
                    
                    enemies.forEach(e => {
                        if (e === this.ignoredTarget || this.hitList.includes(e)) return;
                        
                        const dist = Math.hypot(e.x - this.x, e.y - this.y);
                        
                        // Check if enemy is within the wave band
                        if (dist <= this.radius + e.radius && dist >= innerRadius - e.radius) {
                            // Check Angle
                            const angleToEnemy = Math.atan2(e.y - this.y, e.x - this.x);
                            let angleDiff = angleToEnemy - this.angle;
                            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

                            // Match visual arc width (0.3 PI)
                            if (Math.abs(angleDiff) <= 0.3 * Math.PI) {
                                e.takeDamage(this.damage, '#bae6fd', true);
                                applyColdSlow(e, this.slowDuration);
                                this.hitList.push(e);
                            }
                        }
                    });
                }
            }
            draw() {
                if (this.life <= 0) return;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                // Draw U shape (Shield Impact)
                ctx.beginPath();
                // Arc facing forward (shockwave)
                ctx.arc(0, 0, this.radius, -Math.PI * 0.3, Math.PI * 0.3);
                ctx.strokeStyle = `rgba(186, 230, 253, ${this.life})`; // Light Blue
                ctx.lineWidth = 6 + (1-this.life)*6;
                ctx.lineCap = 'round';
                ctx.stroke();
                
                // Inner echo
                ctx.beginPath();
                ctx.arc(0, 0, this.radius * 0.7, -Math.PI * 0.2, Math.PI * 0.2);
                ctx.strokeStyle = `rgba(224, 242, 254, ${this.life * 0.7})`; // Lighter Blue
                ctx.lineWidth = 3;
                ctx.stroke();

                ctx.restore();
            }
        }

        class LightningBolt {
            constructor(x1, y1, x2, y2, color, duration = 30, delay = 0, onHit = null, options = {}) {
                this.x1 = x1;
                this.y1 = y1;
                this.x2 = x2;
                this.y2 = y2;
                this.color = color;
                this.life = duration;
                this.maxLife = duration;
                this.dead = false;
                this.delay = delay;
                this.onHit = onHit;
                this.hasHit = false;
                this.tendrils = [];
                this.branches = [];
                this.variant = options.variant || 'default';
                
                // Allow width override, or default based on variant
                const baseWidth = options.width || (this.variant === 'level5' ? 5 : 3);

                // Create 1 distinct tendril
                for(let i=0; i<1; i++) {
                    const path = this.generatePath(x1, y1, x2, y2);
                    this.tendrils.push({
                        path: path,
                        width: baseWidth,
                        speed: 0.04 + Math.random() * 0.02, // Speed of travel
                        head: 0, // 0 to 1
                        tail: 0, // 0 to 1
                        length: 0.3 + Math.random() * 0.2 // Length of the tendril
                    });

                    // Generate branches for Level 5
                    if (this.variant === 'level5') {
                        const numBranches = Math.floor(Math.random() * 3) + 2;
                        for(let b=0; b<numBranches; b++) {
                            const spawnIdx = Math.floor(Math.random() * (path.length - 2)) + 1;
                            const spawnPoint = path[spawnIdx];
                            const angle = Math.random() * Math.PI * 2;
                            const len = 30 + Math.random() * 30;
                            const endX = spawnPoint.x + Math.cos(angle) * len;
                            const endY = spawnPoint.y + Math.sin(angle) * len;
                            
                            this.branches.push({
                                path: this.generatePath(spawnPoint.x, spawnPoint.y, endX, endY, 20), // Less sway
                                parentIdx: spawnIdx,
                                width: 2,
                                life: 1.0
                            });
                        }
                    }
                }
            }

            generatePath(x1, y1, x2, y2, initialSway = 80) {
                let points = [{x:x1, y:y1}, {x:x2, y:y2}];
                let sway = initialSway;
                for(let i=0; i<5; i++) {
                    const nextPoints = [points[0]];
                    for(let j=0; j<points.length-1; j++) {
                        const start = points[j];
                        const end = points[j+1];
                        const midX = (start.x + end.x)/2;
                        const midY = (start.y + end.y)/2;
                        const dx = end.x - start.x;
                        const dy = end.y - start.y;
                        const dist = Math.hypot(dx, dy);
                        const nx = -dy/dist;
                        const ny = dx/dist;
                        const offset = (Math.random() - 0.5) * sway;
                        nextPoints.push({
                            x: midX + nx * offset,
                            y: midY + ny * offset
                        });
                        nextPoints.push(end);
                    }
                    points = nextPoints;
                    sway *= 0.5;
                }
                return points;
            }

            update(timeScale) {
                if (this.delay > 0) {
                    this.delay -= timeScale;
                    return;
                }

                let allDead = true;
                let anyHit = false;
                this.tendrils.forEach(t => {
                    t.head += t.speed * timeScale;
                    t.tail = Math.max(0, t.head - t.length);
                    if (t.tail < 1) allDead = false;
                    if (t.head >= 1) anyHit = true;
                });

                if (anyHit && !this.hasHit) {
                    this.hasHit = true;
                    if (this.onHit) this.onHit();
                }

                if (allDead) this.dead = true;
            }

            draw(ctx) {
                if (this.delay > 0) return;

                ctx.save();
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.globalCompositeOperation = 'lighter';

                this.tendrils.forEach(t => {
                    if (t.head <= 0 || t.tail >= 1) return;
                    
                    const totalPoints = t.path.length;
                    const startIdx = Math.floor(t.tail * (totalPoints - 1));
                    const endIdx = Math.min(totalPoints - 1, Math.ceil(t.head * (totalPoints - 1)));
                    
                    if (startIdx >= endIdx) return;

                    // Draw Branches first (if active)
                    if (this.variant === 'level5') {
                        this.branches.forEach(b => {
                            // Only draw branch if the main bolt has passed its spawn point
                            if (t.head * (totalPoints - 1) > b.parentIdx && t.tail * (totalPoints - 1) < b.parentIdx) {
                                ctx.beginPath();
                                ctx.moveTo(b.path[0].x, b.path[0].y);
                                for(let i=1; i<b.path.length; i++) ctx.lineTo(b.path[i].x, b.path[i].y);

                                // Branch Style: Blue Glow + White Core
                                ctx.shadowBlur = 8;
                                ctx.shadowColor = '#3b82f6'; // Blue
                                ctx.strokeStyle = '#3b82f6';
                                ctx.lineWidth = b.width + 2;
                                ctx.stroke();

                                ctx.shadowBlur = 0;
                                ctx.strokeStyle = '#ffffff'; // White
                                ctx.lineWidth = b.width;
                                ctx.stroke();
                            }
                        });
                    }

                    // Main Bolt Drawing
                    ctx.beginPath();
                    ctx.moveTo(t.path[startIdx].x, t.path[startIdx].y);
                    for(let i = startIdx + 1; i <= endIdx; i++) {
                        ctx.lineTo(t.path[i].x, t.path[i].y);
                    }

                    if (this.variant === 'level5') {
                        // 1. Blue Outer Glow
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#3b82f6'; // Blue
                        ctx.strokeStyle = '#3b82f6';
                        ctx.lineWidth = t.width + 4;
                        ctx.stroke();

                        // 2. Yellow Middle
                        ctx.shadowBlur = 0;
                        ctx.strokeStyle = '#facc15'; // Yellow
                        ctx.lineWidth = t.width + 1;
                        ctx.stroke();

                        // 3. White Core
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    } else {
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = this.color;
                        ctx.strokeStyle = this.color;
                        ctx.lineWidth = t.width;
                        ctx.stroke();
                    }
                });
                ctx.restore();
            }
        }

        function createLightningVisual(x1, y1, x2, y2, color, type = 'main', life = 50, options = {}) {
            const delay = options.delay || 0;
            const onHit = options.onHit || null;
            return new LightningBolt(x1, y1, x2, y2, color, life, delay, onHit, options);
        }

        function initLightningParticles() {} // No-op

        function spawnEnemy(typeOverride = null, ignoreCap = false, x = undefined, y = undefined) {
            // Use Difficulty Mult for spawn cap
            // RETUNED: Exponential curve targeting ~400 enemies at 10 mins
            const growth = Math.floor(Math.pow(timer, 1.5) / 35);
            const maxEnemies = (10 + growth) * player.difficultyMult; 
            
            if (!ignoreCap && enemies.length >= maxEnemies) return;

            let type = 'basic';
            if (typeOverride) {
                type = typeOverride;
            } else {
                const rand = Math.random();
                if (timer > 30 && rand < 0.2) type = 'fast';
                if (timer > 60 && rand < 0.1) type = 'tank';
                if (timer > 120 && rand < 0.3) type = 'fast';
            }

            enemies.push(new Enemy(type, currentBossTier, x, y));
        }

        /**
         * UI & GAME LOOP FUNCTIONS
         */
        function initGame() {
            resize();
            window.addEventListener('resize', resize);
            setupInputs();
            initLightningParticles();
        }

        function setupInputs() {
            window.addEventListener('keydown', e => {
                if (e.key === 'Escape') {
                    if (manualPause) {
                        resumeManualPause();
                        return;
                    }
                    if (gameState === 'PLAYING') {
                        pauseManual();
                        return;
                    }
                }

                if (gameState === 'PAUSED') {
                    if (!manualPause) {
                        handleUpgradeInput(e);
                    }
                    return; 
                }
                if (keys.hasOwnProperty(e.key)) keys[e.key] = true;
            });
            window.addEventListener('keyup', e => {
                if (keys.hasOwnProperty(e.key)) keys[e.key] = false;
            });

            canvas.addEventListener('touchstart', e => {
                e.preventDefault();
                const t = e.touches[0];
                touchInput.active = true;
                touchInput.startX = t.clientX;
                touchInput.startY = t.clientY;
                touchInput.currX = t.clientX;
                touchInput.currY = t.clientY;
            }, {passive: false});

            canvas.addEventListener('touchmove', e => {
                e.preventDefault();
                if (!touchInput.active) return;
                const t = e.touches[0];
                touchInput.currX = t.clientX;
                touchInput.currY = t.clientY;
                
                const maxDist = 50;
                let dx = touchInput.currX - touchInput.startX;
                let dy = touchInput.currY - touchInput.startY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist > 10) {
                    touchInput.dx = dx / dist; 
                    touchInput.dy = dy / dist;
                } else {
                    touchInput.dx = 0;
                    touchInput.dy = 0;
                }
            }, {passive: false});

            canvas.addEventListener('touchend', e => {
                e.preventDefault();
                touchInput.active = false;
                touchInput.dx = 0;
                touchInput.dy = 0;
            });
        }

        function pauseManual() {
            if (gameState !== 'PLAYING') return;
            manualPause = true;
            gameState = 'PAUSED';
            Object.keys(keys).forEach(k => keys[k] = false);
            const overlay = document.getElementById('pause-overlay');
            if (overlay) {
                overlay.classList.remove('hidden');
                
                // Populate Stats
                const container = document.getElementById('pause-stats');
                if (container) {
                    container.innerHTML = '';
                    const weaponIcons = { email: 'üìß', aura: 'üåê', offer: 'üíº', referral: '‚ö°' };
                    const weaponNames = { email: 'Cold Email', aura: 'Networking Aura', offer: 'The Offer', referral: 'Referral Chain' };
                    
                    let hasWeapons = false;
                    for (const [id, weapon] of Object.entries(player.weapons)) {
                        if (weapon.level > 0) {
                            hasWeapons = true;
                            const card = document.createElement('div');
                            card.className = 'bg-gray-800 p-3 rounded border border-gray-600 flex flex-col gap-2 text-left';
                            
                            let stats = [];
                            if (weapon.damage) stats.push(`DMG: ${Math.floor(weapon.damage)}`);
                            if (weapon.damageMin) stats.push(`DMG: ${weapon.damageMin}-${weapon.damageMax}`);
                            if (weapon.maxCooldown) stats.push(`CD: ${(weapon.maxCooldown/60).toFixed(1)}s`);
                            if (weapon.range) stats.push(`RNG: ${weapon.range}`);
                            if (weapon.bounce) stats.push(`BNC: ${weapon.bounce}`);

                            card.innerHTML = `
                                <div class="flex items-center gap-2 border-b border-gray-700 pb-2">
                                    <span class="text-2xl">${weaponIcons[id]}</span>
                                    <div>
                                        <div class="font-bold text-yellow-400 text-sm">${weaponNames[id]}</div>
                                        <div class="text-xs text-gray-400">Level ${weapon.level}</div>
                                    </div>
                                </div>
                                <div class="grid grid-cols-2 gap-1 text-xs font-mono text-gray-300">
                                    ${stats.map(s => `<div>${s}</div>`).join('')}
                                </div>
                            `;
                            container.appendChild(card);
                        }
                    }
                    if (!hasWeapons) {
                        container.innerHTML = '<div class="col-span-1 md:col-span-2 text-center text-gray-500 italic">No active requisitions (weapons) yet.</div>';
                    }
                }
            }
        }

        function resumeManualPause() {
            if (!manualPause) return;
            manualPause = false;
            const overlay = document.getElementById('pause-overlay');
            if (overlay) overlay.classList.add('hidden');
            gameState = 'PLAYING';
            lastTime = performance.now();
            requestAnimationFrame(animate);
        }

        function handleUpgradeInput(e) {
            if (upgradeOptions.length === 0) return;

            // Navigate Left / Right (Cards)
            if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
                if (!isRerollFocused) {
                    selectedUpgradeIndex = (selectedUpgradeIndex - 1 + upgradeOptions.length) % upgradeOptions.length;
                    highlightSelectedUpgrade();
                }
            } 
            else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
                if (!isRerollFocused) {
                    selectedUpgradeIndex = (selectedUpgradeIndex + 1) % upgradeOptions.length;
                    highlightSelectedUpgrade();
                }
            }
            // Navigate Down (Focus Reroll)
            else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') {
                if (!isRerollFocused && rerollsRemaining > 0) {
                    isRerollFocused = true;
                    highlightSelectedUpgrade();
                }
            }
            // Navigate Up (Focus Cards)
            else if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
                if (isRerollFocused) {
                    isRerollFocused = false;
                    highlightSelectedUpgrade();
                }
            }
            // Confirm
            else if (e.key === 'Enter' || e.key === ' ') {
                if (isRerollFocused) {
                    rerollUpgrades();
                } else {
                    selectUpgrade(upgradeOptions[selectedUpgradeIndex].id);
                }
            }
            // Reroll Shortcut (R)
            else if (e.key === 'r' || e.key === 'R') {
                rerollUpgrades();
            }
        }

        function highlightSelectedUpgrade() {
            // Handle Cards
            for (let i = 0; i < upgradeOptions.length; i++) {
                const card = document.getElementById(`upgrade-card-${i}`);
                if (!card) continue;
                
                if (!isRerollFocused && i === selectedUpgradeIndex) {
                    card.classList.remove('border-gray-600');
                    card.classList.add('border-white', 'bg-gray-700', 'scale-105', 'shadow-lg', 'shadow-blue-500/50');
                } else {
                    card.classList.add('border-gray-600');
                    card.classList.remove('border-white', 'bg-gray-700', 'scale-105', 'shadow-lg', 'shadow-blue-500/50');
                }
            }

            // Handle Reroll Button
            const rerollBtn = document.getElementById('reroll-btn');
            if (rerollBtn) {
                if (isRerollFocused) {
                    rerollBtn.classList.add('ring-2', 'ring-yellow-400', 'scale-105');
                } else {
                    rerollBtn.classList.remove('ring-2', 'ring-yellow-400', 'scale-105');
                }
            }
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        async function startGame() {
            await Tone.start();
            initAudio();

            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('hud').classList.remove('hidden');
            if (window.innerWidth < 768) {
                document.getElementById('mobile-hint').classList.remove('hidden');
            }

            player = new Player();
            enemies = [];
            projectiles = [];
            gems = [];
            particles = [];
            damageNumbers = [];
            lightnings = []; 
            activeMiniLightnings = 0;
            lingeringSparks = [];
            pulseWaves = []; 
            manualPause = false;
            const pauseOverlay = document.getElementById('pause-overlay');
            if (pauseOverlay) pauseOverlay.classList.add('hidden');
            score = 0;
            timer = 0;
            frameCount = 0;
            bossSpawned = false;
            currentBossTier = 0; 
            rerollsRemaining = 3;
            camera = { x: 0, y: 0, shake: 0 };
            
            updateHUD();

            gameState = 'PAUSED';
            lastTime = performance.now();
            animate(lastTime);
            
            showUpgrades(true);
            
            setInterval(() => {
                if (gameState === 'PLAYING') {
                    timer++;
                    
                    if (timer > 0 && timer % 120 === 0) {
                        if (currentBossTier < BOSS_TIERS.length) {
                            enemies.push(new Enemy('boss', currentBossTier));
                            const bossName = BOSS_TIERS[currentBossTier].name;
                            // Text lasts 3000ms. Lighter Purple.
                            const bossText = { val: `${bossName} HAS ARRIVED`, x: player.x, y: player.y - 100, creationTime: Date.now(), duration: 3000, color: '#d8b4fe' };
                            damageNumbers.push(bossText);
                            camera.shake = 20;
                            currentBossTier++; 
                        }
                    }
                    else if (timer > 0 && timer % 60 === 0) {
                         const swarmSize = 40 + Math.floor(timer/5); 
                         const swarmAngle = Math.random() * Math.PI * 2;
                         const swarmDist = 500; 
                         const centerX = player.x + Math.cos(swarmAngle) * swarmDist;
                         const centerY = player.y + Math.sin(swarmAngle) * swarmDist;

                         for(let i=0; i<swarmSize; i++) {
                             const r = Math.random() * 120; 
                             const theta = Math.random() * Math.PI * 2;
                             const ex = centerX + r * Math.cos(theta);
                             const ey = centerY + r * Math.sin(theta);
                             spawnEnemy('basic', true, ex, ey); 
                         }
                         
                         // SWARM TEXT FIX: Explicit 3000ms duration. Lighter Red.
                         const swarmText = { val: "RESUME SWARM DETECTED!", x: player.x, y: player.y - 150, creationTime: Date.now(), duration: 3000, color: '#fda4af' };
                         damageNumbers.push(swarmText);
                    }

                    updateHUD();
                }
            }, 1000);
        }

        function showUpgrades(isInitial = false) {
            const container = document.getElementById('upgrade-container');
            const title = document.getElementById('upgrade-title');
            
            if (isInitial) {
                title.innerText = "9AM";
            } else {
                title.innerText = "PROMOTION AVAILABLE!";
            }

            container.innerHTML = '';
            upgradeOptions = []; 
            
            let available = [...UPGRADES];
            if (isInitial) {
                available = available.filter(u => u.type === 'WEAPON');
            }

            while(upgradeOptions.length < 3 && available.length > 0) {
                const idx = Math.floor(Math.random() * available.length);
                upgradeOptions.push(available[idx]);
                available.splice(idx, 1); 
            }
            selectedUpgradeIndex = 0; 
            isRerollFocused = false;
            document.getElementById('upgrade-screen').classList.remove('hidden');

            // Update Reroll Button
            const btn = document.getElementById('reroll-btn');
            const countSpan = document.getElementById('reroll-count');
            
            countSpan.innerText = `${rerollsRemaining} Left`;
            
            if (rerollsRemaining > 0) {
                btn.disabled = false;
                btn.classList.remove('opacity-50', 'cursor-not-allowed');
            } else {
                btn.disabled = true;
                btn.classList.add('opacity-50', 'cursor-not-allowed');
            }

            upgradeOptions.forEach((u, index) => {
                const isWeapon = u.type === 'WEAPON';
                const currentLevel = isWeapon ? player.weapons[u.id].level : 0;
                
                // Level Display Logic
                let levelString = '';
                if (isWeapon) {
                    const nextLevel = currentLevel + 1;
                    levelString = `<span class="ml-2 text-gray-500">LVL ${currentLevel} ‚ûú</span> <span class="text-green-400">LVL ${nextLevel}</span>`;
                }

                // Description Logic (Conditional Lvl 2 Text)
                let description = u.desc;
                if (isWeapon) {
                    const nextLevel = currentLevel + 1;
                    if (nextLevel === 2 && u.lvl2Text) {
                        description += `<div class="text-yellow-300 font-bold mt-2 text-xs animate-pulse">‚ú® ${u.lvl2Text}</div>`;
                    } else if (nextLevel === 5 && u.lvl5Text) {
                        description += `<div class="text-blue-300 font-bold mt-2 text-xs animate-pulse">‚ùÑÔ∏è ${u.lvl5Text}</div>`;
                    }
                }

                const card = document.createElement('div');
                card.id = `upgrade-card-${index}`;
                card.className = `bg-gray-800 p-4 rounded border-2 cursor-pointer transition transform duration-150`;
                if (index === selectedUpgradeIndex) {
                    card.classList.add('border-white', 'bg-gray-700', 'scale-105', 'shadow-lg', 'shadow-blue-500/50');
                } else {
                    card.classList.add('border-gray-600');
                }
                card.innerHTML = `
                    <div class="flex items-center gap-3 mb-2 pointer-events-none">
                        <div class="text-4xl">${u.icon}</div>
                        <div>
                            <div class="font-bold text-lg text-white">${u.name}</div>
                            <div class="text-xs text-gray-400 uppercase flex items-center">
                                ${u.type} ${levelString}
                            </div>
                        </div>
                    </div>
                    <p class="text-sm text-gray-300 leading-snug pointer-events-none">${description}</p>
                `;
                card.onmouseenter = () => {
                    selectedUpgradeIndex = index;
                    highlightSelectedUpgrade();
                };
                card.onclick = () => selectUpgrade(u.id);
                container.appendChild(card);
            });
        }

        function rerollUpgrades() {
            if (rerollsRemaining > 0) {
                rerollsRemaining--;
                showUpgrades();
            }
        }

        function selectUpgrade(id) {
            player.upgrade(id);
            document.getElementById('upgrade-screen').classList.add('hidden');
            gameState = 'PLAYING';
            lastTime = performance.now(); 
            requestAnimationFrame(animate);
        }

        function endGame() {
            gameState = 'GAMEOVER';
            const m = Math.floor(timer / 60);
            const s = timer % 60;
            const timeString = `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
            document.getElementById('final-time').innerText = timeString;
            document.getElementById('final-kills').innerText = score;
            document.getElementById('game-over-screen').classList.remove('hidden');
            document.getElementById('hud').classList.add('hidden');
            document.getElementById('boss-hud').classList.add('hidden');
            const msg = TERMINATION_REASONS[Math.floor(Math.random() * TERMINATION_REASONS.length)];
            document.getElementById('static-text-content').innerText = `"${msg}"`;
        }

        function winGame() {
            gameState = 'WIN';
            const m = Math.floor(timer / 60);
            const s = timer % 60;
            const timeString = `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
            document.getElementById('win-time').innerText = timeString;
            document.getElementById('win-kills').innerText = score;
            document.getElementById('win-screen').classList.remove('hidden');
            document.getElementById('hud').classList.add('hidden');
            document.getElementById('boss-hud').classList.add('hidden');
        }

        function updateHUD() {
            if (!player) return;
            const hpPct = (player.hp / player.maxHp) * 100;
            document.getElementById('hp-bar').style.width = `${Math.max(0, hpPct)}%`;
            const xpPct = (player.xp / player.xpToNext) * 100;
            document.getElementById('xp-bar').style.width = `${xpPct}%`;
            const m = Math.floor(timer / 60);
            const s = timer % 60;
            document.getElementById('timer').innerText = `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
            document.getElementById('kill-count').innerText = score;
            document.getElementById('level-display').innerText = player.level;
            document.getElementById('stat-speed').innerText = player.speed.toFixed(2) + 'x';
            document.getElementById('stat-dmg').innerText = player.damageMult.toFixed(2) + 'x';
            document.getElementById('stat-area').innerText = player.areaMult.toFixed(2) + 'x';
            document.getElementById('stat-diff').innerText = player.difficultyMult.toFixed(2) + 'x';
            document.getElementById('stat-cdr').innerText = Math.round(player.attackSpeed * 100) + '%';
            document.getElementById('stat-range').innerText = player.pickupRange;

            const weaponGrid = document.getElementById('weapon-grid');
            weaponGrid.innerHTML = ''; 
            const weaponIcons = { email: 'üìß', aura: 'üåê', offer: 'üíº', referral: '‚ö°' };
            const weaponNames = { email: 'Cold Email', aura: 'Networking Aura', offer: 'The Offer', referral: 'Referral Chain' };

            for (const [id, weapon] of Object.entries(player.weapons)) {
                if (weapon.level > 0) {
                    const badge = document.createElement('div');
                    badge.className = 'bg-gray-700 px-2 py-1 rounded border border-gray-500 flex items-center gap-1 pointer-events-auto relative group cursor-help';
                    
                    let details = `Lvl ${weapon.level}`;
                    if (weapon.damage) details += `\nDmg: ${Math.floor(weapon.damage)}`;
                    if (weapon.damageMin) details += `\nDmg: ${weapon.damageMin}-${weapon.damageMax}`;
                    if (weapon.maxCooldown) details += `\nCD: ${(weapon.maxCooldown/60).toFixed(1)}s`;
                    if (weapon.range) details += `\nRng: ${weapon.range}`;

                    const tooltip = `
                        <div class="absolute top-full left-1/2 transform -translate-x-1/2 mt-2 w-32 bg-black/90 border border-gray-600 p-2 rounded text-[10px] text-left z-50 hidden group-hover:block shadow-xl whitespace-pre-wrap font-mono pointer-events-none">
                            <div class="text-yellow-400 font-bold mb-1 border-b border-gray-700 pb-1">${weaponNames[id]}</div>${details}
                        </div>
                    `;

                    badge.innerHTML = `<span class="text-base">${weaponIcons[id]}</span> <span class="text-yellow-400 font-bold">${weapon.level}</span>${tooltip}`;
                    weaponGrid.appendChild(badge);
                }
            }

            const boss = enemies.find(e => e.type === 'boss');
            const bossHud = document.getElementById('boss-hud');
            if (boss) {
                bossHud.classList.remove('hidden');
                document.getElementById('boss-name').innerText = boss.name;
                document.getElementById('boss-name').style.color = boss.color;
                const bossHpPct = (boss.hp / boss.maxHp) * 100;
                document.getElementById('boss-hp-bar').style.width = `${Math.max(0, bossHpPct)}%`;
            } else {
                bossHud.classList.add('hidden');
            }
        }

        function drawBackground() {
            const gridSize = 100;
            const startCol = Math.floor(camera.x / gridSize);
            const endCol = startCol + (canvas.width / gridSize) + 1;
            const startRow = Math.floor(camera.y / gridSize);
            const endRow = startRow + (canvas.height / gridSize) + 1;
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for (let c = startCol; c <= endCol; c++) {
                let x = c * gridSize;
                if(x < 0 || x > WORLD_WIDTH) continue;
                ctx.moveTo(x, Math.max(0, camera.y));
                ctx.lineTo(x, Math.min(WORLD_HEIGHT, camera.y + canvas.height));
            }
            for (let r = startRow; r <= endRow; r++) {
                let y = r * gridSize;
                if(y < 0 || y > WORLD_HEIGHT) continue;
                ctx.moveTo(Math.max(0, camera.x), y);
                ctx.lineTo(Math.min(WORLD_WIDTH, camera.x + canvas.width), y);
            }
            ctx.stroke();
            ctx.strokeStyle = '#f00';
            ctx.lineWidth = 4;
            ctx.strokeRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);
        }

        function drawMinimap() {
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            const mapSize = 120;
            const mapPaddingX = 20;
            const mapPaddingY = 20; 
            const mapX = mapPaddingX;
            const mapY = canvas.height - mapSize - mapPaddingY;
            const scaleX = mapSize / WORLD_WIDTH;
            const scaleY = mapSize / WORLD_HEIGHT;

            ctx.save();
            ctx.fillStyle = 'rgba(20, 20, 20, 0.9)'; 
            ctx.fillRect(mapX, mapY, mapSize, mapSize);
            ctx.strokeStyle = '#00ff00'; 
            ctx.lineWidth = 2;
            ctx.strokeRect(mapX, mapY, mapSize, mapSize);

            const pMapX = mapX + (player.x * scaleX);
            const pMapY = mapY + (player.y * scaleY);
            ctx.fillStyle = '#ffffff'; 
            ctx.beginPath();
            ctx.arc(pMapX, pMapY, 4, 0, Math.PI*2);
            ctx.fill();

            for (let e of enemies) {
                const eMapX = mapX + (e.x * scaleX);
                const eMapY = mapY + (e.y * scaleY);
                ctx.beginPath();
                if (e.type === 'boss') {
                    ctx.fillStyle = '#9333ea'; 
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.arc(eMapX, eMapY, 6, 0, Math.PI*2); 
                    ctx.fill();
                    ctx.stroke();
                } else {
                    ctx.fillStyle = '#ff0000'; 
                    ctx.rect(eMapX, eMapY, 2, 2);
                    ctx.fill();
                }
            }

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 1;
            ctx.strokeRect(
                mapX + (camera.x * scaleX), 
                mapY + (camera.y * scaleY),
                canvas.width * scaleX,
                canvas.height * scaleY
            );
            ctx.restore();
        }

        function animate(timestamp) {
            if (gameState !== 'PLAYING') return;
            requestAnimationFrame(animate);
            
            // --- DELTA TIME CALCULATION ---
            const dt = timestamp - lastTime;
            lastTime = timestamp;
            // MULTIPLIED BY 3.0 for 1.5x speed request (relative to prev 2.0)
            const timeScale = (dt / 16.67) * 3.0; 
            
            frameCount++;

            let targetCamX = player.x - canvas.width / 2;
            let targetCamY = player.y - canvas.height / 2;

            if (camera.shake > 0) {
                targetCamX += (Math.random() * camera.shake) - (camera.shake/2);
                targetCamY += (Math.random() * camera.shake) - (camera.shake/2);
                camera.shake *= 0.9;
                if(camera.shake < 0.5) camera.shake = 0;
            }

            camera.x = Math.max(0, Math.min(targetCamX, WORLD_WIDTH - canvas.width));
            camera.y = Math.max(0, Math.min(targetCamY, WORLD_HEIGHT - canvas.height));

            ctx.setTransform(1, 0, 0, 1, 0, 0); 
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.translate(-camera.x, -camera.y);

            drawBackground();
            player.update(timeScale);
            
            // Spawn Logic: Dynamic Interval
            // Starts at 60 frames (1s), speeds up to 5 frames (~12/s) over ~10 minutes
            const spawnInterval = Math.max(5, 60 - Math.floor(timer / 10));
            if (frameCount % spawnInterval === 0) spawnEnemy();

            // Projectiles - Safe Loop
            for (let i = projectiles.length - 1; i >= 0; i--) {
                let p = projectiles[i];
                p.update(timeScale);
                p.draw();
                
                // Check against all enemies
                for (let j = 0; j < enemies.length; j++) {
                    let e = enemies[j];
                    const dist = Math.hypot(p.x - e.x, p.y - e.y);
                    
                    if (dist < p.radius + e.radius) {
                        // USE ID FOR HIT CHECK
                        if (p.hitList.includes(e.id)) continue; 

                        let pColor = '#ffffff';
                        if(p.type === 'offer') pColor = '#a0522d'; 
                        else if(p.type === 'email') pColor = '#ffffff'; 
                        
                        let knockbackMult = (p.type === 'email') ? 2.0 : 1.0;
                        
                        // Damage
                        e.takeDamage(p.damage, pColor, false, knockbackMult);
                        
                        p.hitList.push(e.id); // Push ID

                        if (p.type === 'email') {
                            const emailLevel = player.weapons.email.level;
                            if (emailLevel >= 2) {
                                applyColdSlow(e, 150 + (emailLevel * 10));
                                // Snow Effect
                                createParticleBurst({
                                    x: p.x,
                                    y: p.y,
                                    count: 8,
                                    color: '#ffffff',
                                    palette: ['#ffffff', '#e0f2fe', '#dbeafe'],
                                    speed: 1.0,
                                    life: 45,
                                    size: 2.0,
                                    gravity: 0.02, // Gentle fall
                                    friction: 0.96,
                                    fade: true
                                });
                            }
                            if (emailLevel >= 5) {
                                createColdSplash(p.x, p.y, p.damage * 0.45, {
                                    radius: 120,
                                    slowDuration: 150,
                                    ignoredTarget: e,
                                    angle: p.angle
                                });
                            }
                        }
                        
                        if (p.type === 'offer' && player.weapons.offer.level >= 2) {
                            e.stunTimer = 30; // Reverted to 30
                            // Small brown debris for impact
                            createExplosion(p.x, p.y, '#a0522d', 5);
                        }

                        if(p.pierce !== 999) {
                             p.pierce--;
                             if (p.pierce <= 0) p.markedForDeletion = true;
                        }
                        if (p.markedForDeletion) break;
                    }
                }
                if (p.markedForDeletion) projectiles.splice(i, 1);
            }
            
            for (let i = pulseWaves.length - 1; i >= 0; i--) {
                let p = pulseWaves[i];
                p.update(timeScale);
                p.draw();
                if (p.life <= 0) pulseWaves.splice(i, 1);
            }

            for (let i = lingeringSparks.length - 1; i >= 0; i--) {
                let s = lingeringSparks[i];
                s.update(timeScale);
                s.draw();
                
                if (s.tickTimer >= s.tickRate) {
                     s.tickTimer = 0;
                     let hitSomeone = false;
                     enemies.forEach(e => {
                        const dist = Math.hypot(e.x - s.x, e.y - s.y);
                        if (dist < s.radius + e.radius) {
                            // Spark hit: Lighter Yellow AND Small Text
                            e.takeDamage(s.damage, '#fef08a', true);
                            hitSomeone = true;
                        }
                    });
                    if (hitSomeone) s.hitCount++;
                }

                if (s.life <= 0 || s.hitCount >= s.maxHits) lingeringSparks.splice(i, 1);
            }

            // Safe Enemy Update & Removal Loop
            for (let i = enemies.length - 1; i >= 0; i--) {
                let e = enemies[i];
                e.update(timeScale);
                e.draw();
                if (e.hp <= 0) {
                    enemies.splice(i, 1);
                }
            }

            // Lightning Update
            for (let i = lightnings.length - 1; i >= 0; i--) {
                let l = lightnings[i];
                l.update(timeScale);
                
                // Only draw if on screen
                if (Math.max(l.x1, l.x2) > camera.x && Math.min(l.x1, l.x2) < camera.x + canvas.width &&
                    Math.max(l.y1, l.y2) > camera.y && Math.min(l.y1, l.y2) < camera.y + canvas.height) {
                    l.draw(ctx);
                }

                if (l.dead) {
                    lightnings.splice(i, 1);
                }
            }

            gems.forEach(g => {
                if (g.x >= camera.x && g.x <= camera.x + canvas.width &&
                    g.y >= camera.y && g.y <= camera.y + canvas.height) {
                    
                    if (g.type === 'pizza') {
                        ctx.font = "24px Arial";
                        ctx.textAlign = "center";
                        ctx.textBaseline = "middle";
                        ctx.fillText("üçï", g.x, g.y);
                    } else if (g.type === 'magnet') {
                        ctx.font = "24px Arial";
                        ctx.textAlign = "center";
                        ctx.textBaseline = "middle";
                        ctx.fillText("üß≤", g.x, g.y);
                    } else {
                        ctx.fillStyle = g.color || '#60a5fa';
                        ctx.beginPath();
                        ctx.arc(g.x, g.y, g.radius || 4, 0, Math.PI*2);
                        ctx.fill();
                        if (Math.random() < 0.1) {
                            ctx.fillStyle = 'white';
                            ctx.fillRect(g.x, g.y, 2, 2);
                        }
                    }
                }
            });

            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update(timeScale);
                particles[i].draw();
                if (particles[i].life <= 0) particles.splice(i, 1);
            }

            // Damage Numbers
            const now = Date.now();
            for (let i = damageNumbers.length - 1; i >= 0; i--) {
                let d = damageNumbers[i];
                
                d.y -= 0.5 * timeScale;
                
                if (d.x >= camera.x && d.x <= camera.x + canvas.width &&
                    d.y >= camera.y && d.y <= camera.y + canvas.height) {
                    
                    const elapsed = now - d.creationTime;
                    const alpha = Math.max(0, 1 - (elapsed / d.duration));
                    
                    ctx.save();
                    ctx.globalAlpha = alpha;
                    
                    if (d.isEffect) {
                        ctx.font = "italic bold 20px 'Segoe UI', sans-serif";
                        ctx.fillStyle = d.color;
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 1;
                    } else {
                        ctx.font = "900 36px 'Arial Black', Gadget, sans-serif";
                        ctx.lineWidth = 3;
                        ctx.fillStyle = d.color; 
                        ctx.strokeStyle = "#000000"; 
                    }

                    ctx.strokeText(d.val, d.x, d.y);
                    ctx.fillText(d.val, d.x, d.y);
                    ctx.restore();
                }
                
                if (now > d.creationTime + d.duration) {
                    damageNumbers.splice(i, 1);
                }
            }

            player.draw();
            ctx.restore();
            drawMinimap();

            if (touchInput.active) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(touchInput.startX, touchInput.startY, 40, 0, Math.PI * 2);
                ctx.stroke();
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.beginPath();
                ctx.arc(touchInput.currX, touchInput.currY, 15, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        initGame();
    </script>
</body>
</html>